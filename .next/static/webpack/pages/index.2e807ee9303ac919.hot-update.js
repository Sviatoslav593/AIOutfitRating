"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("pages/index",{

/***/ "./utils/imageValidation.js":
/*!**********************************!*\
  !*** ./utils/imageValidation.js ***!
  \**********************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   analyzeImageBasics: function() { return /* binding */ analyzeImageBasics; },\n/* harmony export */   isLikelyOutfit: function() { return /* binding */ isLikelyOutfit; }\n/* harmony export */ });\n/**\n * Basic image validation utilities for outfit detection\n */ /**\n * Analyze image dimensions and basic properties\n */ function analyzeImageBasics(file) {\n    return new Promise((resolve)=>{\n        const img = new Image();\n        const canvas = document.createElement(\"canvas\");\n        const ctx = canvas.getContext(\"2d\");\n        img.onload = ()=>{\n            canvas.width = img.width;\n            canvas.height = img.height;\n            ctx.drawImage(img, 0, 0);\n            const imageData = ctx.getImageData(0, 0, img.width, img.height);\n            const analysis = {\n                width: img.width,\n                height: img.height,\n                aspectRatio: img.width / img.height,\n                colorAnalysis: analyzeColors(imageData),\n                isLikelyScreenshot: detectScreenshot(img.width, img.height),\n                isLikelyIcon: detectIcon(img.width, img.height)\n            };\n            resolve(analysis);\n        };\n        img.src = URL.createObjectURL(file);\n    });\n}\n/**\n * Detect if image is likely a screenshot\n */ function detectScreenshot(width, height) {\n    // Common screenshot dimensions\n    const commonScreenResolutions = [\n        {\n            w: 1920,\n            h: 1080\n        },\n        {\n            w: 1366,\n            h: 768\n        },\n        {\n            w: 1440,\n            h: 900\n        },\n        {\n            w: 1280,\n            h: 720\n        },\n        {\n            w: 1536,\n            h: 864\n        },\n        {\n            w: 1600,\n            h: 900\n        }\n    ];\n    return commonScreenResolutions.some((res)=>Math.abs(width - res.w) < 10 && Math.abs(height - res.h) < 10) || width > 1200 && height > 600 && Math.abs(width / height - 16 / 9) < 0.1;\n}\n/**\n * Detect if image is likely an icon or logo\n */ function detectIcon(width, height) {\n    // Very small images or perfect squares are likely icons\n    return width < 200 && height < 200 || Math.abs(width - height) < 10 && width < 500;\n}\n/**\n * Analyze color distribution\n */ function analyzeColors(imageData) {\n    const data = imageData.data;\n    let totalPixels = data.length / 4;\n    let colorVariance = 0;\n    let averageR = 0, averageG = 0, averageB = 0;\n    // Calculate average colors\n    for(let i = 0; i < data.length; i += 4){\n        averageR += data[i];\n        averageG += data[i + 1];\n        averageB += data[i + 2];\n    }\n    averageR /= totalPixels;\n    averageG /= totalPixels;\n    averageB /= totalPixels;\n    // Calculate color variance\n    for(let i = 0; i < data.length; i += 4){\n        const rDiff = data[i] - averageR;\n        const gDiff = data[i + 1] - averageG;\n        const bDiff = data[i + 2] - averageB;\n        colorVariance += rDiff * rDiff + gDiff * gDiff + bDiff * bDiff;\n    }\n    colorVariance /= totalPixels;\n    return {\n        variance: colorVariance,\n        isMonochrome: colorVariance < 1000,\n        averageColor: {\n            r: averageR,\n            g: averageG,\n            b: averageB\n        }\n    };\n}\n/**\n * Determine if image is likely an outfit photo\n */ function isLikelyOutfit(analysis) {\n    const { width, height, aspectRatio, colorAnalysis, isLikelyScreenshot, isLikelyIcon } = analysis;\n    // Definitely not outfit indicators\n    if (isLikelyScreenshot || isLikelyIcon) {\n        return {\n            isOutfit: false,\n            reason: isLikelyScreenshot ? \"screenshot\" : \"icon\"\n        };\n    }\n    // Very monochrome images are likely logos\n    if (colorAnalysis.isMonochrome) {\n        return {\n            isOutfit: false,\n            reason: \"monochrome\"\n        };\n    }\n    // Portrait orientation is more likely to be outfit photos\n    const isPortrait = aspectRatio < 0.8;\n    const isSquare = Math.abs(aspectRatio - 1) < 0.2;\n    // Good indicators for outfit photos (більш м'які критерії)\n    const hasGoodDimensions = width >= 150 && height >= 150;\n    const hasColorVariety = colorAnalysis.variance > 1000; // Зменшили поріг\n    const hasReasonableAspectRatio = aspectRatio > 0.2 && aspectRatio < 5; // Розширили діапазон\n    if (hasGoodDimensions && hasColorVariety && hasReasonableAspectRatio) {\n        return {\n            isOutfit: true,\n            confidence: isPortrait ? 0.8 : 0.6\n        };\n    }\n    // Якщо не пройшли базові перевірки, але це не очевидно не-аутфіт, даємо шанс\n    if (hasGoodDimensions && hasReasonableAspectRatio) {\n        return {\n            isOutfit: true,\n            confidence: 0.4\n        }; // Низька впевненість, але не блокуємо\n    }\n    return {\n        isOutfit: false,\n        reason: \"low_confidence\"\n    };\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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VUFBVTtZQUFNTyxZQUFZTCxhQUFhLE1BQU07UUFBSTtJQUM5RDtJQUVBLDZFQUE2RTtJQUM3RSxJQUFJRSxxQkFBcUJFLDBCQUEwQjtRQUNqRCxPQUFPO1lBQUVOLFVBQVU7WUFBTU8sWUFBWTtRQUFJLEdBQUcsc0NBQXNDO0lBQ3BGO0lBRUEsT0FBTztRQUFFUCxVQUFVO1FBQU9DLFFBQVE7SUFBaUI7QUFDckQiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vdXRpbHMvaW1hZ2VWYWxpZGF0aW9uLmpzP2UzODQiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBCYXNpYyBpbWFnZSB2YWxpZGF0aW9uIHV0aWxpdGllcyBmb3Igb3V0Zml0IGRldGVjdGlvblxuICovXG5cbi8qKlxuICogQW5hbHl6ZSBpbWFnZSBkaW1lbnNpb25zIGFuZCBiYXNpYyBwcm9wZXJ0aWVzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhbmFseXplSW1hZ2VCYXNpY3MoZmlsZSkge1xuICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICBjb25zdCBpbWcgPSBuZXcgSW1hZ2UoKTtcbiAgICBjb25zdCBjYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiY2FudmFzXCIpO1xuICAgIGNvbnN0IGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KFwiMmRcIik7XG5cbiAgICBpbWcub25sb2FkID0gKCkgPT4ge1xuICAgICAgY2FudmFzLndpZHRoID0gaW1nLndpZHRoO1xuICAgICAgY2FudmFzLmhlaWdodCA9IGltZy5oZWlnaHQ7XG4gICAgICBjdHguZHJhd0ltYWdlKGltZywgMCwgMCk7XG5cbiAgICAgIGNvbnN0IGltYWdlRGF0YSA9IGN0eC5nZXRJbWFnZURhdGEoMCwgMCwgaW1nLndpZHRoLCBpbWcuaGVpZ2h0KTtcbiAgICAgIGNvbnN0IGFuYWx5c2lzID0ge1xuICAgICAgICB3aWR0aDogaW1nLndpZHRoLFxuICAgICAgICBoZWlnaHQ6IGltZy5oZWlnaHQsXG4gICAgICAgIGFzcGVjdFJhdGlvOiBpbWcud2lkdGggLyBpbWcuaGVpZ2h0LFxuICAgICAgICBjb2xvckFuYWx5c2lzOiBhbmFseXplQ29sb3JzKGltYWdlRGF0YSksXG4gICAgICAgIGlzTGlrZWx5U2NyZWVuc2hvdDogZGV0ZWN0U2NyZWVuc2hvdChpbWcud2lkdGgsIGltZy5oZWlnaHQpLFxuICAgICAgICBpc0xpa2VseUljb246IGRldGVjdEljb24oaW1nLndpZHRoLCBpbWcuaGVpZ2h0KSxcbiAgICAgIH07XG5cbiAgICAgIHJlc29sdmUoYW5hbHlzaXMpO1xuICAgIH07XG5cbiAgICBpbWcuc3JjID0gVVJMLmNyZWF0ZU9iamVjdFVSTChmaWxlKTtcbiAgfSk7XG59XG5cbi8qKlxuICogRGV0ZWN0IGlmIGltYWdlIGlzIGxpa2VseSBhIHNjcmVlbnNob3RcbiAqL1xuZnVuY3Rpb24gZGV0ZWN0U2NyZWVuc2hvdCh3aWR0aCwgaGVpZ2h0KSB7XG4gIC8vIENvbW1vbiBzY3JlZW5zaG90IGRpbWVuc2lvbnNcbiAgY29uc3QgY29tbW9uU2NyZWVuUmVzb2x1dGlvbnMgPSBbXG4gICAgeyB3OiAxOTIwLCBoOiAxMDgwIH0sXG4gICAgeyB3OiAxMzY2LCBoOiA3NjggfSxcbiAgICB7IHc6IDE0NDAsIGg6IDkwMCB9LFxuICAgIHsgdzogMTI4MCwgaDogNzIwIH0sXG4gICAgeyB3OiAxNTM2LCBoOiA4NjQgfSxcbiAgICB7IHc6IDE2MDAsIGg6IDkwMCB9LFxuICBdO1xuXG4gIHJldHVybiAoXG4gICAgY29tbW9uU2NyZWVuUmVzb2x1dGlvbnMuc29tZShcbiAgICAgIChyZXMpID0+IE1hdGguYWJzKHdpZHRoIC0gcmVzLncpIDwgMTAgJiYgTWF0aC5hYnMoaGVpZ2h0IC0gcmVzLmgpIDwgMTBcbiAgICApIHx8XG4gICAgKHdpZHRoID4gMTIwMCAmJiBoZWlnaHQgPiA2MDAgJiYgTWF0aC5hYnMod2lkdGggLyBoZWlnaHQgLSAxNiAvIDkpIDwgMC4xKVxuICApO1xufVxuXG4vKipcbiAqIERldGVjdCBpZiBpbWFnZSBpcyBsaWtlbHkgYW4gaWNvbiBvciBsb2dvXG4gKi9cbmZ1bmN0aW9uIGRldGVjdEljb24od2lkdGgsIGhlaWdodCkge1xuICAvLyBWZXJ5IHNtYWxsIGltYWdlcyBvciBwZXJmZWN0IHNxdWFyZXMgYXJlIGxpa2VseSBpY29uc1xuICByZXR1cm4gKFxuICAgICh3aWR0aCA8IDIwMCAmJiBoZWlnaHQgPCAyMDApIHx8XG4gICAgKE1hdGguYWJzKHdpZHRoIC0gaGVpZ2h0KSA8IDEwICYmIHdpZHRoIDwgNTAwKVxuICApO1xufVxuXG4vKipcbiAqIEFuYWx5emUgY29sb3IgZGlzdHJpYnV0aW9uXG4gKi9cbmZ1bmN0aW9uIGFuYWx5emVDb2xvcnMoaW1hZ2VEYXRhKSB7XG4gIGNvbnN0IGRhdGEgPSBpbWFnZURhdGEuZGF0YTtcbiAgbGV0IHRvdGFsUGl4ZWxzID0gZGF0YS5sZW5ndGggLyA0O1xuICBsZXQgY29sb3JWYXJpYW5jZSA9IDA7XG4gIGxldCBhdmVyYWdlUiA9IDAsXG4gICAgYXZlcmFnZUcgPSAwLFxuICAgIGF2ZXJhZ2VCID0gMDtcblxuICAvLyBDYWxjdWxhdGUgYXZlcmFnZSBjb2xvcnNcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBkYXRhLmxlbmd0aDsgaSArPSA0KSB7XG4gICAgYXZlcmFnZVIgKz0gZGF0YVtpXTtcbiAgICBhdmVyYWdlRyArPSBkYXRhW2kgKyAxXTtcbiAgICBhdmVyYWdlQiArPSBkYXRhW2kgKyAyXTtcbiAgfVxuXG4gIGF2ZXJhZ2VSIC89IHRvdGFsUGl4ZWxzO1xuICBhdmVyYWdlRyAvPSB0b3RhbFBpeGVscztcbiAgYXZlcmFnZUIgLz0gdG90YWxQaXhlbHM7XG5cbiAgLy8gQ2FsY3VsYXRlIGNvbG9yIHZhcmlhbmNlXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7IGkgKz0gNCkge1xuICAgIGNvbnN0IHJEaWZmID0gZGF0YVtpXSAtIGF2ZXJhZ2VSO1xuICAgIGNvbnN0IGdEaWZmID0gZGF0YVtpICsgMV0gLSBhdmVyYWdlRztcbiAgICBjb25zdCBiRGlmZiA9IGRhdGFbaSArIDJdIC0gYXZlcmFnZUI7XG4gICAgY29sb3JWYXJpYW5jZSArPSByRGlmZiAqIHJEaWZmICsgZ0RpZmYgKiBnRGlmZiArIGJEaWZmICogYkRpZmY7XG4gIH1cblxuICBjb2xvclZhcmlhbmNlIC89IHRvdGFsUGl4ZWxzO1xuXG4gIHJldHVybiB7XG4gICAgdmFyaWFuY2U6IGNvbG9yVmFyaWFuY2UsXG4gICAgaXNNb25vY2hyb21lOiBjb2xvclZhcmlhbmNlIDwgMTAwMCwgLy8gVmVyeSBsb3cgdmFyaWFuY2UgPSBsaWtlbHkgbG9nby9pY29uXG4gICAgYXZlcmFnZUNvbG9yOiB7IHI6IGF2ZXJhZ2VSLCBnOiBhdmVyYWdlRywgYjogYXZlcmFnZUIgfSxcbiAgfTtcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgaW1hZ2UgaXMgbGlrZWx5IGFuIG91dGZpdCBwaG90b1xuICovXG5leHBvcnQgZnVuY3Rpb24gaXNMaWtlbHlPdXRmaXQoYW5hbHlzaXMpIHtcbiAgY29uc3Qge1xuICAgIHdpZHRoLFxuICAgIGhlaWdodCxcbiAgICBhc3BlY3RSYXRpbyxcbiAgICBjb2xvckFuYWx5c2lzLFxuICAgIGlzTGlrZWx5U2NyZWVuc2hvdCxcbiAgICBpc0xpa2VseUljb24sXG4gIH0gPSBhbmFseXNpcztcblxuICAvLyBEZWZpbml0ZWx5IG5vdCBvdXRmaXQgaW5kaWNhdG9yc1xuICBpZiAoaXNMaWtlbHlTY3JlZW5zaG90IHx8IGlzTGlrZWx5SWNvbikge1xuICAgIHJldHVybiB7XG4gICAgICBpc091dGZpdDogZmFsc2UsXG4gICAgICByZWFzb246IGlzTGlrZWx5U2NyZWVuc2hvdCA/IFwic2NyZWVuc2hvdFwiIDogXCJpY29uXCIsXG4gICAgfTtcbiAgfVxuXG4gIC8vIFZlcnkgbW9ub2Nocm9tZSBpbWFnZXMgYXJlIGxpa2VseSBsb2dvc1xuICBpZiAoY29sb3JBbmFseXNpcy5pc01vbm9jaHJvbWUpIHtcbiAgICByZXR1cm4geyBpc091dGZpdDogZmFsc2UsIHJlYXNvbjogXCJtb25vY2hyb21lXCIgfTtcbiAgfVxuXG4gIC8vIFBvcnRyYWl0IG9yaWVudGF0aW9uIGlzIG1vcmUgbGlrZWx5IHRvIGJlIG91dGZpdCBwaG90b3NcbiAgY29uc3QgaXNQb3J0cmFpdCA9IGFzcGVjdFJhdGlvIDwgMC44O1xuICBjb25zdCBpc1NxdWFyZSA9IE1hdGguYWJzKGFzcGVjdFJhdGlvIC0gMSkgPCAwLjI7XG5cbiAgLy8gR29vZCBpbmRpY2F0b3JzIGZvciBvdXRmaXQgcGhvdG9zICjQsdGW0LvRjNGIINC8J9GP0LrRliDQutGA0LjRgtC10YDRltGXKVxuICBjb25zdCBoYXNHb29kRGltZW5zaW9ucyA9IHdpZHRoID49IDE1MCAmJiBoZWlnaHQgPj0gMTUwO1xuICBjb25zdCBoYXNDb2xvclZhcmlldHkgPSBjb2xvckFuYWx5c2lzLnZhcmlhbmNlID4gMTAwMDsgLy8g0JfQvNC10L3RiNC40LvQuCDQv9C+0YDRltCzXG4gIGNvbnN0IGhhc1JlYXNvbmFibGVBc3BlY3RSYXRpbyA9IGFzcGVjdFJhdGlvID4gMC4yICYmIGFzcGVjdFJhdGlvIDwgNTsgLy8g0KDQvtC30YjQuNGA0LjQu9C4INC00ZbQsNC/0LDQt9C+0L1cblxuICBpZiAoaGFzR29vZERpbWVuc2lvbnMgJiYgaGFzQ29sb3JWYXJpZXR5ICYmIGhhc1JlYXNvbmFibGVBc3BlY3RSYXRpbykge1xuICAgIHJldHVybiB7IGlzT3V0Zml0OiB0cnVlLCBjb25maWRlbmNlOiBpc1BvcnRyYWl0ID8gMC44IDogMC42IH07XG4gIH1cblxuICAvLyDQr9C60YnQviDQvdC1INC/0YDQvtC50YjQu9C4INCx0LDQt9C+0LLRliDQv9C10YDQtdCy0ZbRgNC60LgsINCw0LvQtSDRhtC1INC90LUg0L7Rh9C10LLQuNC00L3QviDQvdC1LdCw0YPRgtGE0ZbRgiwg0LTQsNGU0LzQviDRiNCw0L3RgVxuICBpZiAoaGFzR29vZERpbWVuc2lvbnMgJiYgaGFzUmVhc29uYWJsZUFzcGVjdFJhdGlvKSB7XG4gICAgcmV0dXJuIHsgaXNPdXRmaXQ6IHRydWUsIGNvbmZpZGVuY2U6IDAuNCB9OyAvLyDQndC40LfRjNC60LAg0LLQv9C10LLQvdC10L3RltGB0YLRjCwg0LDQu9C1INC90LUg0LHQu9C+0LrRg9GU0LzQvlxuICB9XG5cbiAgcmV0dXJuIHsgaXNPdXRmaXQ6IGZhbHNlLCByZWFzb246IFwibG93X2NvbmZpZGVuY2VcIiB9O1xufVxuIl0sIm5hbWVzIjpbImFuYWx5emVJbWFnZUJhc2ljcyIsImZpbGUiLCJQcm9taXNlIiwicmVzb2x2ZSIsImltZyIsIkltYWdlIiwiY2FudmFzIiwiZG9jdW1lbnQiLCJjcmVhdGVFbGVtZW50IiwiY3R4IiwiZ2V0Q29udGV4dCIsIm9ubG9hZCIsIndpZHRoIiwiaGVpZ2h0IiwiZHJhd0ltYWdlIiwiaW1hZ2VEYXRhIiwiZ2V0SW1hZ2VEYXRhIiwiYW5hbHlzaXMiLCJhc3BlY3RSYXRpbyIsImNvbG9yQW5hbHlzaXMiLCJhbmFseXplQ29sb3JzIiwiaXNMaWtlbHlTY3JlZW5zaG90IiwiZGV0ZWN0U2NyZWVuc2hvdCIsImlzTGlrZWx5SWNvbiIsImRldGVjdEljb24iLCJzcmMiLCJVUkwiLCJjcmVhdGVPYmplY3RVUkwiLCJjb21tb25TY3JlZW5SZXNvbHV0aW9ucyIsInciLCJoIiwic29tZSIsInJlcyIsIk1hdGgiLCJhYnMiLCJkYXRhIiwidG90YWxQaXhlbHMiLCJsZW5ndGgiLCJjb2xvclZhcmlhbmNlIiwiYXZlcmFnZVIiLCJhdmVyYWdlRyIsImF2ZXJhZ2VCIiwiaSIsInJEaWZmIiwiZ0RpZmYiLCJiRGlmZiIsInZhcmlhbmNlIiwiaXNNb25vY2hyb21lIiwiYXZlcmFnZUNvbG9yIiwiciIsImciLCJiIiwiaXNMaWtlbHlPdXRmaXQiLCJpc091dGZpdCIsInJlYXNvbiIsImlzUG9ydHJhaXQiLCJpc1NxdWFyZSIsImhhc0dvb2REaW1lbnNpb25zIiwiaGFzQ29sb3JWYXJpZXR5IiwiaGFzUmVhc29uYWJsZUFzcGVjdFJhdGlvIiwiY29uZmlkZW5jZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./utils/imageValidation.js\n"));

/***/ })

});